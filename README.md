# 1. 项目起步

## 1.1 开发工具

使用 HBuilderX 来开发 uni-app 类型的项目

## 1.2 安装 scss/sass 编译

为了方便编写样式（例如：`<style lang="scss"></style>`），要安装 `scss/sass 编译` 插件。

## 1.3 目录结构

### 1.3.1 项目页面的搭建

| 页面名称 | 文件         |
| -------- | ------------ |
| 首页     | home         |
| 分类     | cate         |
| 购物车   | cart         |
| 个人中心 | my           |
| 商品列表 | goods_list   |
| 商品详情 | goods_detail |
| 地址     | my-address   |
| 搜索     | top_SPsearch |
| 登录     | my-login     |
|          |              |
|          |              |
|          |              |



# 2. tabBar 配置

## 2.1 创建 tabBar 页面

在 `pages` 目录中，创建首页(home)、分类(cate)、购物车(cart)、我的(my) 这 4 个 tabBar 页面。

## 2.2 配置 tabBar 效果

修改项目根目录中的 `pages.json` 配置文件，新增 `tabBar` 的配置节点。



# 3. 首页

## 3.1 配置网络请求

由于平台的限制，小程序项目中**不支持 axios**，而且原生的 `wx.request()` API 功能较为简单，**不支持拦截器**等全局定制的功能。因此，建议在 uni-app 项目中使用 `@escook/request-miniprogram` 第三方包发起网络数据请求。

1. 在项目的 `main.js` 入口文件中，通过如下的方式进行配置：

   ```JavaScript
   import { $http } from '@escook/request-miniprogram'
   
   uni.$http = $http
   
   // 配置请求根路径
   $http.baseUrl = 'https://www.uinav.com'
   
   // 请求开始之前做一些事情
   $http.beforeRequest = function (options) {
     uni.showLoading({
       title: '数据加载中...',
     })
   }
   
   // 请求完成之后做一些事情
   $http.afterRequest = function () {
     uni.hideLoading()
   }
   ```

2. 将所有的代码都放到 main.js 中，main.js 将非常冗余。在项目的根目录下创建 common 文件夹，在文件夹中创建 request.js 文件，专门用来处理请求。

3. 将 request.js 文件在 main.js 中导入。

   ```JavaScript
   // 导入请求配置文件
   import './common/request.js'
   ```

## 3.2 轮播图区域

1. 在 data 中定义轮播图的数组
2. 在 onLoad 生命周期函数中调用获取轮播图数据的方法
3. 在 methods 中定义获取轮播图数据的方法

### 3.2.1 配置小程序分包

**分包可以减少小程序首次启动时的加载时间**

1. 在项目根目录中，创建分包的根目录，命名为 `subpkg`。
2. 在 `pages.json` 中，和 `pages` 节点平级的位置声明 `subPackages` 节点，用来定义分包相关的结构。
3. 在 `subpkg` 目录上鼠标右键，点击 `新建页面` 选项，并填写页面的相关信息。

### 3.2.2 封装 uni.$showMsg() 方法

当数据请求失败之后，经常需要调用 `uni.showToast({ /* 配置对象 */ })` 方法来提示用户。此时，可以在全局封装一个 `uni.$showMsg()` 方法，来简化 `uni.showToast()` 方法的调用。

1. 在 `main.js` 中，为 `uni` 对象挂载自定义的 `$showMsg()` 方法：

   ```JavaScript
   // 封装的展示消息提示的方法
   uni.$showMsg = function (title = '数据加载失败！', duration = 1500) {
     uni.showToast({
       title,
       duration,
       icon: 'none',
     })
   }
   ```

2. 在需要提示消息的时候，直接调用 `uni.$showMsg()` 方法即可。

## 3.3 分类导航区域

1. 定义 data 数据
2. 在 onLoad 中调用获取数据的方法
3. 在 methods 中定义获取数据的方法

## 3.4 楼层区域

### 3.4.1 获取楼层数据

### 3.4.2 渲染楼层的标题

### 3.4.3 渲染楼层里的图片

### 3.4.4点击楼层图片跳转到商品列表页



# 4. 分类

关键技术：对请求到的数据进行多层次渲染，实现Tab点击切换渲染不同数据

注意事项：页面初始默认数据的渲染，以及点击相应的商品类型跳转至对应的商品列表，正确获取点击商品的cat_id并传递给商品列表页面，在列表页作为参数请求数据



# 5. 搜索

## 5.1 输入框绑定值改变事件 input事件

- 获取到输入框的值
- 合法性判断 (非空)
- 检验通过 把输入框的值 发送到后台
- 返回的数据打印到页面上

## 5.2 防抖（防止抖动）定时器 节流

- 防抖 一般 输入框中 防止重复输入 重复发送请求
- 节流 一般是用在页面下拉和上拉
- 定义全局的定时器id



# 6. 商品详情

## 6.1 点击图片预览

## 6.2 加入购物车逻辑

- 先绑定点击事件

- 获取缓存中的购物车数据数组格式

- 先判断当前的商品是否已经存在于购物车

- 已经存在，修改商品数据，执行购物车数量++，重新把购物车数组填充回缓存中

- 不存在于购物车的数组中，直接给购物车数组添加一个新元素，新元素带上购买数量属性 num 重新把购物车组填充回缓存中

- 弹出提示

  ```JavaScript
   // 点击 加入购物车
    handleCartAdd() {
      // 1 获取缓存中的购物车 数组
      let cart = wx.getStorageSync("cart") || [];
      // 2 判断 商品对象是否存在于购物车数组中
      let index = cart.findIndex(v => v.goods_id === this.GoodsInfo.goods_id);
      if (index === -1) {
        //3  不存在 第一次添加
        this.GoodsInfo.num = 1;
        this.GoodsInfo.checked = true;
        cart.push(this.GoodsInfo);
      } else {
        // 4 已经存在购物车数据 执行 num++
        cart[index].num++;
      }
      // 5 把购物车重新添加回缓存中
      wx.setStorageSync("cart", cart);
      // 6 弹窗提示
      wx.showToast({
        title: '加入成功',
        icon: 'success',
        // true 防止用户 手抖 疯狂点击按钮 
        mask: true
      });
  
    }
  ```



# 7. 商品列表

## 7.1 下拉刷新

1. 要实现下拉刷新的页面的json中定义 “enablePullDownRefresh”:true,“backgroundTextStyle”:"dark"这两个属性，他才能实现下拉刷新。
2. 在data写一个数组来接受第一次接口接收到的数据。
3. 在onPullDownRefresh下拉刷新事件中写入具体的操作：先写一个wx.showLoading在 数据请求之前， 写一个关闭在数据请求结束后，用展开运算符来写把第一次请求的数据和第二次请求来的数据进行拼接，并储存渲染。

## 7.2 上拉加载

1. 先写一个对象用来存取从接口中请求来我们所需要的数据。
2. 启⽤上拉⻚⾯功能 onReachBottom ⻚⾯触底事件，监听页面的上拉触底行为。

## 7.3 通过节流阀防止发起额外的请求

1. 在 data 中定义 `isloading` 节流阀。
2. 在发起网络请求数据前后，分别打开和关闭节流阀。
3. 在 `onReachBottom` 触底事件处理函数中，根据节流阀的状态，来决定是否发起请求

## 7.4 判断数据是否加载完毕

如果下面的公式成立，则证明没有下一页数据了：

```text
当前的页码值 * 每页显示多少条数据 >= 总数条数
pagenum * pagesize >= total
```



# 8. 购物车

关键技术：对本地数据的存储及获取，添加购物车是对商品的逻辑判断，获取用户收货地址.

**点击加入购物车时，要先通过本地是否有token验证用户是否已登录，并判断商品先前是否已经添加至购物车，以及对购物车商品数量的增加，复选框选中状态的获取以及响应式对商品数量的修改，并动态改变总价以及小计数量。**



# 9. 登录

## 9.1 实现登录和用户信息组件的按需展示

## 9.2 点击登录按钮获取微信用户的基本信息

## 9.3 将用户的基本信息存储到 vuex

## 9.4 登录获取 Token 字符串

## 9.5 将 Token 存储到 vuex

## 9.6 三秒后自动跳转到登录页面

**需求描述：在购物车页面，当用户点击 “结算” 按钮时，如果用户没有登录，则 3 秒后自动跳转到登录页面。**

## 9.7 登录成功之后再返回之前的页面

**核心实现思路：在自动跳转到登录页面成功之后，把返回页面的信息存储到 vuex 中，从而方便登录成功之后，根据返回页面的信息重新跳转回去。**



# 10. 支付

## 10.1 在请求头中添加 Token 身份认证的字段

**只有在登录之后才允许调用支付相关的接口**，所以必须为有权限的接口添加身份认证的请求头字段

```javascript
// 请求开始之前做一些事情
$http.beforeRequest = function(options) {
  uni.showLoading({
    title: '数据加载中...',
  })

  // 判断请求的是否为有权限的 API 接口
  if (options.url.indexOf('/my/') !== -1) {
    // 为请求头添加身份认证字段
    options.header = {
      // 字段的值可以直接从 vuex 中进行获取
      Authorization: store.state.m_user.token,
    }
  }
}
```



## 10.2 微信支付的流程

1. 创建订单
   - 请求创建订单的 API 接口：把（订单金额、收货地址、订单中包含的商品信息）发送到服务器
   - 服务器响应的结果：*订单编号*
2. 订单预支付
   - 请求订单预支付的 API 接口：把（订单编号）发送到服务器
   - 服务器响应的结果：*订单预支付的参数对象*，里面包含了订单支付相关的必要参数
3. 发起微信支付
   - 调用 `uni.requestPayment()` 这个 API，发起微信支付；把步骤 2 得到的 “订单预支付对象” 作为参数传递给 `uni.requestPayment()` 方法
   - 监听 `uni.requestPayment()` 这个 API 的 `success`，`fail`，`complete` 回调函数

**因为支付功能需要权限，所以支付功能没有实现**。



# 11. 发布

## 11.1 发布小程序的流程

点击 `HBuilderX` 菜单栏上的 `发行` -> `小程序-微信(仅适用于uni-app)`；在弹出框中填写要发布的**小程序的名称**和**AppId**之后，点击发行按钮；发布编译完成之后，会自动打开一个新的**微信开发者工具界面**，此时，填写**版本号**和**项目备注**之后，点击工具栏上的上传按钮；将 `开发版本提交审核` -> 再将 `审核通过的版本发布上线`，即可实现小程序的发布和上线。

## 11.2 发布为 Android App 的流程

打开项目根目录中的 `manifest.json` 配置文件，在**基础配置**面板中，获取**uni-app 应用标识**，并填写**应用名称**；切换到 **App 图标配置**面板，点击**浏览**按钮，选择合适的图片之后，再点击**自动生成所有图标并替换**；点击菜单栏上的 **发行** -> **原生 App-云打包**；在**控制台**中**查看打包的进度信息**，跳转到本地的打包目录，**安装到 Android 手机中**查看打包的效果。

**注意：由于开发期间没有进行多端适配，所以有些功能在 App 中无法正常运行，例如：选择收货地址、微信登录、微信支付**。

